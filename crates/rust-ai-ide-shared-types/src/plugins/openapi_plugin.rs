//! OpenAPI/Swagger plugin for the shared types crate
//!
//! This plugin generates OpenAPI 3.0 specifications from Rust types,
//! enabling automatic REST API documentation.

use crate::plugins::*;
use crate::{serde_json, ParsedType, TransformationContext};
use async_trait::async_trait;

/// OpenAPI generator plugin
#[derive(Debug)]
pub struct OpenAPIGeneratorPlugin;

impl OpenAPIGeneratorPlugin {
    pub fn new() -> Self {
        Self
    }
}

#[async_trait]
impl GeneratorPluginTrait for OpenAPIGeneratorPlugin {
    fn name(&self) -> &str {
        "openapi-generator"
    }

    fn target_platforms(&self) -> Vec<String> {
        vec![
            "openapi".to_string(),
            "swagger".to_string(),
            "rest".to_string(),
        ]
    }

    fn supported_formats(&self) -> Vec<String> {
        vec!["3.0".to_string(), "3.1".to_string()]
    }

    async fn generate(
        &self,
        types: &[ParsedType],
        platform: &str,
        config: &serde_json::Value,
    ) -> Result<GeneratedCode, PluginError> {
        let openapi_version = config
            .get("openapi_version")
            .and_then(|v| v.as_str())
            .unwrap_or("3.0.3");

        let title = config
            .get("title")
            .and_then(|v| v.as_str())
            .unwrap_or("API");

        let version = config
            .get("version")
            .and_then(|v| v.as_str())
            .unwrap_or("1.0.0");

        let include_responses = config
            .get("responses")
            .unwrap_or(&serde_json::Value::Bool(true))
            .as_bool()
            .unwrap_or(true);

        let mut spec = serde_json::json!({
            "openapi": openapi_version,
            "info": {
                "title": title,
                "version": version,
                "description": "Generated by rust-ai-ide-shared-types"
            },
            "paths": {},
            "components": {
                "schemas": {}
            }
        });

        // Add schemas for each type
        if let Some(schemas) = spec["components"]["schemas"].as_object_mut() {
            for rust_type in types {
                let schema = self.generate_schema(rust_type);
                schemas.insert(rust_type.name.clone(), schema);
            }
        }

        // Add example paths if requested
        if include_responses
            && config
                .get("example_paths")
                .unwrap_or(&serde_json::Value::Bool(false))
                .as_bool()
                .unwrap_or(false)
        {
            self.add_example_paths(&mut spec, types);
        }

        let content = serde_json::to_string_pretty(&spec)
            .map_err(|e| PluginError::ExecutionError(e.to_string()))?;

        Ok(GeneratedCode {
            content,
            target_platform: platform.to_string(),
            source_types: types.to_vec(),
            metadata: crate::generation::GenerationMetadata {
                generated_at: chrono::Utc::now().to_rfc3339(),
                generator_version: env!("CARGO_PKG_VERSION").to_string(),
                config_snapshot: config.clone(),
                stats: crate::generation::GenerationStats {
                    types_processed: types.len(),
                    types_generated: types.len(),
                    bytes_generated: content.len(),
                    generation_time_ms: 0,
                    warnings_count: 0,
                    errors_count: 0,
                },
                status: crate::generation::GenerationStatus::Success,
            },
            dependencies: vec![],
        })
    }

    async fn validate(&self) -> Result<(), PluginError> {
        Ok(()) // OpenAPI generator is always valid
    }

    fn metadata(&self) -> PluginMetadata {
        PluginMetadata {
            name: "openapi-generator".to_string(),
            version: "1.0.0".to_string(),
            author: "Rust AI IDE Team".to_string(),
            description: "Generates OpenAPI specifications from Rust types".to_string(),
            homepage: Some("https://github.com/rust-ai-ide/rust-ai-ide".to_string()),
            platforms: vec!["openapi".to_string(), "swagger".to_string()],
            license: Some("MIT OR Apache-2.0".to_string()),
            dependencies: vec![],
        }
    }
}

impl OpenAPIGeneratorPlugin {
    fn generate_schema(&self, rust_type: &ParsedType) -> serde_json::Value {
        let mut properties = serde_json::json!({});
        let mut required = Vec::new();

        if let Some(props) = properties.as_object_mut() {
            for field in &rust_type.fields {
                let schema = self.generate_field_schema(&field.ty);
                props.insert(field.name.clone(), schema);

                // Add to required if not optional
                if !field.ty.contains("Option<") {
                    required.push(field.name.clone());
                }
            }
        }

        let mut schema = serde_json::json!({
            "type": "object",
            "properties": properties
        });

        if !required.is_empty() {
            schema["required"] = serde_json::json!(required);
        }

        // Add documentation
        if let Some(ref docs) = rust_type.documentation {
            schema["description"] = serde_json::json!(docs.replace("\n", " "));
        }

        schema
    }

    fn generate_field_schema(&self, rust_type: &str) -> serde_json::Value {
        if let Some(inner) = rust_type.strip_prefix("Option<") {
            let inner = inner.trim_end_matches(">");
            let schema = self.generate_field_schema(inner);
            let mut wrapper = serde_json::json!({"oneOf": [schema, {"type": "null"}]});
            return wrapper;
        }

        if let Some(inner) = rust_type.strip_prefix("Vec<") {
            let inner = inner.trim_end_matches(">");
            let item_schema = self.generate_field_schema(inner);
            return serde_json::json!({
                "type": "array",
                "items": item_schema
            });
        }

        let (json_type, format) = self.rust_type_to_openapi_type(rust_type);

        let mut schema = serde_json::json!({"type": json_type});

        if let Some(fmt) = format {
            schema["format"] = serde_json::json!(fmt);
        }

        schema
    }

    fn rust_type_to_openapi_type(&self, rust_type: &str) -> (&str, Option<&str>) {
        match rust_type {
            "String" | "str" => ("string", None),
            "i8" | "i16" | "i32" | "u8" | "u16" | "u32" => ("integer", Some("int32")),
            "i64" | "u64" => ("integer", Some("int64")),
            "f32" => ("number", Some("float")),
            "f64" => ("number", Some("double")),
            "bool" => ("boolean", None),
            "chrono::NaiveDateTime" => ("string", Some("date-time")),
            t if t.contains("chrono::DateTime") => ("string", Some("date-time")),
            _ => ("object", None), // Default for custom types
        }
    }

    fn add_example_paths(&self, spec: &mut serde_json::Value, types: &[ParsedType]) {
        if let Some(paths) = spec["paths"].as_object_mut() {
            for rust_type in types {
                let type_name = &rust_type.name;
                let path = format!("/{}", crate::utils::string_utils::to_snake_case(type_name));

                let mut path_item = serde_json::json!({});

                // Add GET operation
                path_item["get"] = serde_json::json!({
                    "summary": format!("Get {}", type_name),
                    "operationId": format!("get{}", type_name),
                    "responses": {
                        "200": {
                            "description": "Success",
                            "content": {
                                "application/json": {
                                    "schema": {
                                        "type": "array",
                                        "items": {
                                            "$ref": format!("#/components/schemas/{}", type_name)
                                        }
                                    }
                                }
                            }
                        }
                    }
                });

                paths.insert(path, path_item);
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parsing::TypeParser;

    #[tokio::test]
    async fn test_openapi_plugin_generation() {
        let plugin = OpenAPIGeneratorPlugin::new();

        let source = r#"
            /// A user entity
            pub struct User {
                /// Unique identifier
                pub id: u32,
                /// User's full name
                pub name: String,
                /// Email address
                pub email: Option<String>,
            }
        "#;

        let parser = TypeParser::new();
        let types = parser.parse_file(source, "test.rs").unwrap();

        let config = serde_json::json!({
            "title": "Test API",
            "version": "1.0.0"
        });
        let result = plugin.generate(&types, "openapi", &config).await.unwrap();

        // Parse result as JSON to validate
        let spec: serde_json::Value = serde_json::from_str(&result.content).unwrap();

        assert_eq!(spec["openapi"], "3.0.3");
        assert_eq!(spec["info"]["title"], "Test API");
        assert!(spec["components"]["schemas"]["User"].is_object());

        let user_schema = &spec["components"]["schemas"]["User"];
        assert_eq!(user_schema["type"], "object");

        // Check properties
        let id_prop = &user_schema["properties"]["id"];
        assert_eq!(id_prop["type"], "integer");
        assert_eq!(id_prop["format"], "int32");

        // Check required fields (email is optional)
        let required = &user_schema["required"];
        assert!(required
            .as_array()
            .unwrap()
            .contains(&serde_json::json!("id")));
        assert!(required
            .as_array()
            .unwrap()
            .contains(&serde_json::json!("name")));
        assert!(!required
            .as_array()
            .unwrap()
            .contains(&serde_json::json!("email")));
    }
}
