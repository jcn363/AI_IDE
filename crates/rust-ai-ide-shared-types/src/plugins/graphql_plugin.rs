//! GraphQL plugin for the shared types crate
//!
//! This plugin generates GraphQL schemas from Rust types, enabling
//! seamless API definitions for GraphQL services.

use crate::plugins::*;
use crate::{serde_json, ParsedType, TransformationContext};
use async_trait::async_trait;

/// GraphQL generator plugin
#[derive(Debug)]
pub struct GraphQLGeneratorPlugin;

impl GraphQLGeneratorPlugin {
    pub fn new() -> Self {
        Self
    }
}

#[async_trait]
impl GeneratorPluginTrait for GraphQLGeneratorPlugin {
    fn name(&self) -> &str {
        "graphql-generator"
    }

    fn target_platforms(&self) -> Vec<String> {
        vec!["graphql".to_string(), "gql".to_string()]
    }

    fn supported_formats(&self) -> Vec<String> {
        vec![
            "schema".to_string(),
            "federation".to_string(),
            "subscription".to_string(),
        ]
    }

    async fn generate(
        &self,
        types: &[ParsedType],
        platform: &str,
        config: &serde_json::Value,
    ) -> Result<GeneratedCode, PluginError> {
        let schema_type = config
            .get("schema_type")
            .and_then(|v| v.as_str())
            .unwrap_or("basic");

        let generate_mutations = config
            .get("mutations")
            .unwrap_or(&serde_json::Value::Bool(true))
            .as_bool()
            .unwrap_or(true);

        let generate_subscriptions = config
            .get("subscriptions")
            .unwrap_or(&serde_json::Value::Bool(false))
            .as_bool()
            .unwrap_or(false);

        let mut content = String::from("# Generated by rust-ai-ide-shared-types\n\n");

        match schema_type {
            "federation" => self.generate_federation_schema(
                &mut content,
                types,
                generate_mutations,
                generate_subscriptions,
            ),
            "subscription" => self.generate_subscription_schema(&mut content, types),
            _ => self.generate_basic_schema(&mut content, types, generate_mutations),
        }

        Ok(GeneratedCode {
            content,
            target_platform: platform.to_string(),
            source_types: types.to_vec(),
            metadata: crate::generation::GenerationMetadata {
                generated_at: chrono::Utc::now().to_rfc3339(),
                generator_version: env!("CARGO_PKG_VERSION").to_string(),
                config_snapshot: config.clone(),
                stats: crate::generation::GenerationStats {
                    types_processed: types.len(),
                    types_generated: types.len(),
                    bytes_generated: content.len(),
                    generation_time_ms: 0,
                    warnings_count: 0,
                    errors_count: 0,
                },
                status: crate::generation::GenerationStatus::Success,
            },
            dependencies: vec![],
        })
    }

    async fn validate(&self) -> Result<(), PluginError> {
        Ok(()) // GraphQL generator is always valid
    }

    fn metadata(&self) -> PluginMetadata {
        PluginMetadata {
            name: "graphql-generator".to_string(),
            version: "1.0.0".to_string(),
            author: "Rust AI IDE Team".to_string(),
            description: "Generates GraphQL schemas from Rust types".to_string(),
            homepage: Some("https://github.com/rust-ai-ide/rust-ai-ide".to_string()),
            platforms: vec!["graphql".to_string()],
            license: Some("MIT OR Apache-2.0".to_string()),
            dependencies: vec![],
        }
    }
}

impl GraphQLGeneratorPlugin {
    fn generate_basic_schema(
        &self,
        content: &mut String,
        types: &[ParsedType],
        with_mutations: bool,
    ) {
        // Generate schema header
        content.push_str("schema {\n");
        content.push_str("  query: Query\n");
        if with_mutations {
            content.push_str("  mutation: Mutation\n");
        }
        content.push_str("}\n\n");

        // Generate type definitions
        for rust_type in types {
            self.generate_graphql_type(content, rust_type);
            if !rust_type.fields.is_empty() {
                content.push('\n');
            }
        }

        if with_mutations {
            self.generate_basic_mutations(content, types);
        }
    }

    fn generate_federation_schema(
        &self,
        content: &mut String,
        types: &[ParsedType],
        with_mutations: bool,
        with_subscriptions: bool,
    ) {
        // Federation schema with Apollo Federation support
        content.push_str("extend schema\n");
        content.push_str("  @link(url: \"https://specs.apollo.dev/federation/v2.0\",\n");
        content.push_str("        import: [\"@key\", \"@shareable\"])\n\n");

        content.push_str("schema {\n");
        content.push_str("  query: Query\n");
        if with_mutations {
            content.push_str("  mutation: Mutation\n");
        }
        if with_subscriptions {
            content.push_str("  subscription: Subscription\n");
        }
        content.push_str("}\n\n");

        // Generate federated types
        for rust_type in types {
            content.push_str(&format!("type {} @shareable {{\n", rust_type.name));

            for field in &rust_type.fields {
                let graphql_type = self.rust_field_to_graphql_type(&field.ty);
                let nullable = if field.ty.contains("Option<") {
                    ""
                } else {
                    "!"
                };
                content.push_str(&format!("  {}{}: {}\n", field.name, nullable, graphql_type));
            }

            content.push_str("}\n\n");
        }
    }

    fn generate_subscription_schema(&self, content: &mut String, types: &[ParsedType]) {
        content.push_str("schema {\n");
        content.push_str("  query: Query\n");
        content.push_str("  subscription: Subscription\n");
        content.push_str("}\n\n");

        // Generate subscription type
        content.push_str("type Subscription {\n");
        for rust_type in types {
            if let Some(ref docs) = rust_type.documentation {
                content.push_str(&format!(
                    "  \"\"\"\n  {}\n  \"\"\"\n",
                    docs.replace("\n", "\n  ")
                ));
            }
            content.push_str(&format!(
                "  {}: {}\n",
                self.to_subscription_name(rust_type),
                rust_type.name
            ));
        }
        content.push_str("}\n\n");

        // Generate object types
        for rust_type in types {
            self.generate_graphql_type(content, rust_type);
            content.push('\n');
        }
    }

    fn generate_graphql_type(&self, content: &mut String, rust_type: &ParsedType) {
        if let Some(ref docs) = rust_type.documentation {
            content.push_str(&format!("\"\"\"\n{}\n\"\"\"\n", docs.replace("\n", "\n")));
        }

        content.push_str(&format!("type {} {{\n", rust_type.name));

        for field in &rust_type.fields {
            if let Some(ref field_docs) = field.documentation {
                content.push_str(&format!(
                    "  \"\"\"\n  {}\n  \"\"\"\n",
                    field_docs.replace("\n", "\n  ")
                ));
            }

            let graphql_type = self.rust_field_to_graphql_type(&field.ty);
            let nullable = if field.ty.contains("Option<") {
                ""
            } else {
                "!"
            };
            content.push_str(&format!("  {}{}: {}\n", field.name, nullable, graphql_type));
        }

        content.push_str("}\n");
    }

    fn generate_basic_mutations(&self, content: &mut String, types: &[ParsedType]) {
        content.push_str("\ntype Mutation {\n");

        for rust_type in types {
            let type_name = rust_type.name.clone();

            // Create mutation
            content.push_str(&format!(
                "  create{}(input: {}Input!): {}\n",
                type_name, type_name, type_name
            ));
            content.push_str(&format!(
                "  update{}(id: ID!, input: {}Input!): {}\n",
                type_name, type_name, type_name
            ));
            content.push_str(&format!("  delete{}(id: ID!): Boolean!\n", type_name));
        }

        content.push_str("}\n\n");

        // Generate input types
        for rust_type in types {
            content.push_str(&format!("input {}Input {{\n", rust_type.name));

            for field in &rust_type.fields {
                let graphql_type = self.rust_field_to_graphql_type(&field.ty);
                let nullable = ""; // Input fields are nullable by default
                content.push_str(&format!("  {}{}: {}\n", field.name, nullable, graphql_type));
            }

            content.push_str("}\n\n");
        }
    }

    fn rust_field_to_graphql_type(&self, rust_type: &str) -> String {
        let base_type = if let Some(inner) = rust_type.strip_prefix("Option<") {
            inner.trim_end_matches(">").trim()
        } else {
            rust_type
        };

        let graphql_type = match base_type {
            t if t.contains("Vec<") => {
                let inner = t.trim_start_matches("Vec<").trim_end_matches(">").trim();
                self.rust_type_to_graphql_type(inner) + "!"
            }
            t => self.rust_type_to_graphql_type(t),
        };

        // For nullable types (Option<T>), let the nullable mark be handled at the field level
        if rust_type.contains("Option<") {
            graphql_type
        } else {
            graphql_type + "!"
        }
    }

    fn rust_type_to_graphql_type(&self, rust_type: &str) -> String {
        match rust_type {
            "String" | "str" => "String".to_string(),
            "i32" | "i64" | "u32" | "u64" => "Int".to_string(),
            "f32" | "f64" => "Float".to_string(),
            "bool" => "Boolean".to_string(),
            "chrono::NaiveDateTime" => "DateTime".to_string(),
            t if t.contains("chrono::DateTime") => "DateTime".to_string(),
            t => t.to_string(), // Custom types stay as-is
        }
    }

    fn to_subscription_name(&self, rust_type: &ParsedType) -> String {
        let type_name = &rust_type.name;
        format!(
            "on{}",
            crate::utils::string_utils::to_pascal_case(type_name)
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parsing::TypeParser;

    #[tokio::test]
    async fn test_graphql_plugin_basic() {
        let plugin = GraphQLGeneratorPlugin::new();

        let source = r#"
            /// A user entity
            pub struct User {
                /// Unique identifier
                pub id: u32,
                /// User's name
                pub name: String,
                /// Optional email
                pub email: Option<String>,
            }
        "#;

        let parser = TypeParser::new();
        let types = parser.parse_file(source, "test.rs").unwrap();

        let config = serde_json::json!({"schema_type": "basic"});
        let result = plugin.generate(&types, "graphql", &config).await.unwrap();

        assert!(result.content.contains("schema {"));
        assert!(result.content.contains("type User {"));
        assert!(result.content.contains("id: Int!"));
        assert!(result.content.contains("name: String!"));
        assert!(result.content.contains("email: String"));
    }

    #[tokio::test]
    async fn test_graphql_plugin_with_mutations() {
        let plugin = GraphQLGeneratorPlugin::new();

        let source = r#"pub struct Post { pub id: u32, pub title: String }"#;

        let parser = TypeParser::new();
        let types = parser.parse_file(source, "test.rs").unwrap();

        let config = serde_json::json!({"mutations": true});
        let result = plugin.generate(&types, "graphql", &config).await.unwrap();

        assert!(result.content.contains("mutation: Mutation"));
        assert!(result.content.contains("createPost"));
        assert!(result.content.contains("updatePost"));
        assert!(result.content.contains("deletePost"));
        assert!(result.content.contains("input PostInput"));
    }

    #[tokio::test]
    async fn test_graphql_plugin_federation() {
        let plugin = GraphQLGeneratorPlugin::new();

        let source = r#"pub struct Product { pub id: String, pub name: String }"#;

        let parser = TypeParser::new();
        let types = parser.parse_file(source, "test.rs").unwrap();

        let config = serde_json::json!({"schema_type": "federation"});
        let result = plugin.generate(&types, "graphql", &config).await.unwrap();

        assert!(result.content.contains("@shareable"));
        assert!(result.content.contains("extend schema"));
        assert!(result.content.contains("@link"));
    }
}
