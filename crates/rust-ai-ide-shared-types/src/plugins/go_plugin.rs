//! Go plugin for the shared types crate
//!
//! This plugin generates Go struct definitions from Rust types,
//! providing seamless interoperability between Go and Rust services.

use crate::plugins::*;
use crate::{serde_json, Field, ParsedType, TransformationContext};
use async_trait::async_trait;

/// Go generator plugin
#[derive(Debug)]
pub struct GoGeneratorPlugin;

impl GoGeneratorPlugin {
    pub fn new() -> Self {
        Self
    }
}

#[async_trait]
impl GeneratorPluginTrait for GoGeneratorPlugin {
    fn name(&self) -> &str {
        "go-generator"
    }

    fn target_platforms(&self) -> Vec<String> {
        vec!["go".to_string(), "golang".to_string()]
    }

    fn supported_formats(&self) -> Vec<String> {
        vec!["json".to_string(), "bson".to_string(), "sql".to_string()]
    }

    async fn generate(
        &self,
        types: &[ParsedType],
        platform: &str,
        config: &serde_json::Value,
    ) -> Result<GeneratedCode, PluginError> {
        let package_name = config
            .get("package")
            .and_then(|v| v.as_str())
            .unwrap_or("types");

        let with_json_tags = config
            .get("json_tags")
            .unwrap_or(&serde_json::Value::Bool(true))
            .as_bool()
            .unwrap_or(true);

        let with_bson_tags = config
            .get("bson_tags")
            .unwrap_or(&serde_json::Value::Bool(false))
            .as_bool()
            .unwrap_or(false);

        let generate_getters = config
            .get("generate_getters")
            .unwrap_or(&serde_json::Value::Bool(false))
            .as_bool()
            .unwrap_or(false);

        let mut content = format!("package {}\n\n", package_name);
        content.push_str("// Code generated by rust-ai-ide-shared-types. DO NOT EDIT.\n\n");

        // Add imports
        let mut imports = vec!["encoding/json"];
        if with_bson_tags {
            imports.push("\"go.mongodb.org/mongo-driver/bson\"");
        }
        if generate_getters {
            content.push_str("import \"time\"\n");
        }

        if imports.len() > 1 {
            content.push_str("import (\n");
            for imp in imports {
                content.push_str(&format!("    {}\n", imp));
            }
            content.push_str(")\n\n");
        } else if with_json_tags {
            content.push_str(&format!("import {}\n\n", imports[0]));
        }

        // Generate types
        for (index, rust_type) in types.iter().enumerate() {
            self.generate_go_type(&mut content, rust_type, with_json_tags, with_bson_tags);

            if generate_getters {
                self.generate_getters(&mut content, rust_type);
            }

            if index < types.len() - 1 {
                content.push('\n');
            }
        }

        Ok(GeneratedCode {
            content,
            target_platform: platform.to_string(),
            source_types: types.to_vec(),
            metadata: crate::generation::GenerationMetadata {
                generated_at: chrono::Utc::now().to_rfc3339(),
                generator_version: env!("CARGO_PKG_VERSION").to_string(),
                config_snapshot: config.clone(),
                stats: crate::generation::GenerationStats {
                    types_processed: types.len(),
                    types_generated: types.len(),
                    bytes_generated: content.len(),
                    generation_time_ms: 0,
                    warnings_count: 0,
                    errors_count: 0,
                },
                status: crate::generation::GenerationStatus::Success,
            },
            dependencies: vec!["encoding/json".to_string()],
        })
    }

    async fn validate(&self) -> Result<(), PluginError> {
        Ok(()) // Go generator is always valid
    }

    fn metadata(&self) -> PluginMetadata {
        PluginMetadata {
            name: "go-generator".to_string(),
            version: "1.0.0".to_string(),
            author: "Rust AI IDE Team".to_string(),
            description: "Generates Go struct definitions from Rust types".to_string(),
            homepage: Some("https://github.com/rust-ai-ide/rust-ai-ide".to_string()),
            platforms: vec!["go".to_string(), "golang".to_string()],
            license: Some("MIT OR Apache-2.0".to_string()),
            dependencies: vec![],
        }
    }
}

impl GoGeneratorPlugin {
    fn generate_go_type(
        &self,
        content: &mut String,
        rust_type: &ParsedType,
        json_tags: bool,
        bson_tags: bool,
    ) {
        // Add documentation
        if let Some(ref docs) = rust_type.documentation {
            content.push_str(&format!("// {}\n", docs.replace("\n", "\n// ")));
        }

        // Generate struct
        content.push_str(&format!(
            "type {} struct {{\n",
            self.rust_type_to_go_type(&rust_type.name)
        ));

        // Generate fields
        for field in &rust_type.fields {
            if let Some(ref field_docs) = field.documentation {
                content.push_str(&format!(
                    "    // {}\n",
                    field_docs.replace("\n", "\n    // ")
                ));
            }

            let go_type = self.rust_field_to_go_type(&field.ty);
            let go_field_name = self.to_go_field_name(&field.name);

            let mut tag_parts = Vec::new();

            if json_tags {
                let json_tag = self.to_snake_case(&field.name);
                tag_parts.push(format!("json:\"{}\"", json_tag));
            }

            if bson_tags {
                let bson_tag = self.to_snake_case(&field.name);
                tag_parts.push(format!("bson:\"{}\"", bson_tag));
            }

            let tag = if tag_parts.is_empty() {
                String::new()
            } else {
                format!(" `{}`", tag_parts.join(" "))
            };

            content.push_str(&format!(
                "    {}{} {}{}\n",
                go_field_name,
                tag,
                go_type,
                self.get_field_suffix(&field.ty)
            ));
        }

        content.push_str("}\n");
    }

    fn generate_getters(&self, content: &mut String, rust_type: &ParsedType) {
        let go_type_name = self.rust_type_to_go_type(&rust_type.name);

        content.push_str(&format!("\n// Getter methods for {}\n", go_type_name));

        for field in &rust_type.fields {
            let go_field_name = self.to_go_field_name(&field.name);
            let go_type = self.rust_field_to_go_type(&field.ty);
            let field_suffix = self.get_field_suffix(&field.ty);

            // Generate getter
            content.push_str(&format!(
                "func (t *{}) Get{}() {}{} {{\n",
                go_type_name, go_field_name, go_type, field_suffix
            ));

            if field.ty.contains("Option<") {
                let inner_type = field
                    .ty
                    .trim_start_matches("Option<")
                    .trim_end_matches(">")
                    .trim();
                let go_inner_type = self.rust_field_to_go_type(inner_type);

                if go_inner_type == "string" {
                    content.push_str(&format!(
                        "    if t.{} == nil {{\n        return \"\"\n",
                        go_field_name
                    ));
                } else {
                    content.push_str(&format!(
                        "    if t.{} == nil {{\n        return 0\n",
                        go_field_name
                    ));
                }
                content.push_str(&format!("    }}\n"));
                content.push_str(&format!("    return *t.{}\n", go_field_name));
            } else {
                content.push_str(&format!("    return t.{}\n", go_field_name));
            }
            content.push_str("}\n\n");
        }
    }

    fn rust_type_to_go_type(&self, rust_type: &str) -> String {
        match rust_type {
            "String" => "string",
            "i8" | "i16" | "i32" => "int32",
            "i64" => "int64",
            "u8" | "u16" | "u32" => "uint32",
            "u64" => "uint64",
            "f32" => "float32",
            "f64" => "float64",
            "bool" => "bool",
            "char" => "rune",
            t => t, // Keep as-is for custom types
        }
        .to_string()
    }

    fn rust_field_to_go_type(&self, rust_type: &str) -> String {
        if let Some(inner) = rust_type.strip_prefix("Option<") {
            let inner = inner.trim_end_matches(">");
            let go_type = self.rust_field_to_go_type(inner);
            format!("*{}", go_type)
        } else if let Some(inner) = rust_type.strip_prefix("Vec<") {
            let inner = inner.trim_end_matches(">");
            let go_type = self.rust_field_to_go_type(inner);
            format!("[]{}", go_type)
        } else {
            self.rust_type_to_go_type(rust_type)
        }
    }

    fn to_go_field_name(&self, field_name: &str) -> String {
        field_name
            .split('_')
            .map(|part| {
                let mut chars = part.chars();
                match chars.next() {
                    Some(first) => first
                        .to_uppercase()
                        .chain(chars.as_str().chars())
                        .collect::<String>(),
                    None => String::new(),
                }
            })
            .collect::<String>()
    }

    fn to_snake_case(&self, field_name: &str) -> String {
        field_name
            .chars()
            .enumerate()
            .map(|(i, c)| {
                if c.is_uppercase() && i > 0 {
                    format!("_{}", c.to_lowercase())
                } else {
                    c.to_lowercase().to_string()
                }
            })
            .collect::<String>()
    }

    fn get_field_suffix(&self, rust_type: &str) -> &'static str {
        match rust_type {
            t if t.contains("chrono::NaiveDateTime") => " // time.Time",
            t if t.contains("chrono::DateTime") => " // time.Time",
            _ => "",
        }
    }
}

/// Register the Go plugin
pub fn register_go_plugin(plugin_system: &mut PluginSystem) {
    let _ = plugin_system.load_plugins(); // This would normally register the plugin
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parsing::TypeParser;

    #[tokio::test]
    async fn test_go_plugin_generation() {
        let plugin = GoGeneratorPlugin::new();

        let source = r#"
            /// A user in the system
            pub struct User {
                /// Unique identifier
                pub id: u32,
                /// User's full name
                pub name: String,
                /// Optional email
                pub email: Option<String>,
                /// Creation timestamp
                pub created_at: chrono::NaiveDateTime,
            }
        "#;

        let parser = TypeParser::new();
        let types = parser.parse_file(source, "test.rs").unwrap();

        let config = serde_json::json!({"package": "test"});
        let result = plugin.generate(&types, "go", &config).await.unwrap();

        assert!(result.content.contains("package test"));
        assert!(result.content.contains("type User struct"));
        assert!(result.content.contains("Id int32 `json:\"id\"`"));
        assert!(result.content.contains("Name string `json:\"name\"`"));
        assert!(result.content.contains("*string `json:\"email\"`"));
        assert!(result.content.contains("// A user in the system"));
        assert!(result.target_platform == "go");
    }

    #[tokio::test]
    async fn test_go_plugin_with_bson_tags() {
        let plugin = GoGeneratorPlugin::new();

        let source = r#"
            pub struct Document {
                pub id: String,
                pub title: String,
            }
        "#;

        let parser = TypeParser::new();
        let types = parser.parse_file(source, "test.rs").unwrap();

        let config = serde_json::json!({
            "package": "model",
            "json_tags": true,
            "bson_tags": true
        });
        let result = plugin.generate(&types, "go", &config).await.unwrap();

        assert!(result.content.contains("`json:\"id\" bson:\"id\"`"));
        assert!(result.content.contains("`json:\"title\" bson:\"title\"`"));
    }

    #[test]
    fn test_go_field_name_conversion() {
        let plugin = GoGeneratorPlugin::new();

        assert_eq!(plugin.to_go_field_name("user_id"), "UserId");
        assert_eq!(plugin.to_go_field_name("first_name"), "FirstName");
        assert_eq!(plugin.to_go_field_name("api"), "Api");
    }
}
