#!/bin/bash

# Rust AI IDE Vulnerability Scanner
# Automated security maintenance script integrating cargo-audit and cargo-deny
# This script scans for vulnerabilities, enforces security policies, and generates reports

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../../.." && pwd)"
REPORTS_DIR="$PROJECT_ROOT/security-reports"
HISTORY_DIR="$REPORTS_DIR/history"
AUDIT_DB_PATH="${AUDIT_DB_PATH:-}"
CARGO_DENY_CONFIG="${CARGO_DENY_CONFIG:-$PROJECT_ROOT/deny.toml}"

# Environment variables for configuration
SEVERITY_THRESHOLD="${SEVERITY_THRESHOLD:-medium}"  # low, medium, high, critical
FAIL_ON_CRITICAL="${FAIL_ON_CRITICAL:-true}"
EMERGENCY_CVE="${EMERGENCY_CVE:-}"
GENERATE_HTML="${GENERATE_HTML:-true}"
SLACK_WEBHOOK="${SLACK_WEBHOOK:-}"
EMAIL_RECIPIENTS="${EMAIL_RECIPIENTS:-}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# Ensure required tools are installed
check_dependencies() {
    local missing_tools=()

    if ! command -v cargo &> /dev/null; then
        missing_tools+=("cargo")
    fi

    if ! command -v jq &> /dev/null; then
        missing_tools+=("jq")
    fi

    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        log_error "Missing required tools: ${missing_tools[*]}"
        log_error "Please install them and try again."
        exit 1
    fi

    # Check for cargo-audit
    if ! cargo install --list | grep -q "cargo-audit"; then
        log_warn "cargo-audit not found. Installing..."
        cargo install cargo-audit
    fi

    # Check for cargo-deny
    if ! cargo install --list | grep -q "cargo-deny"; then
        log_warn "cargo-deny not found. Installing..."
        cargo install cargo-deny
    fi
}

# Create directories
setup_directories() {
    mkdir -p "$REPORTS_DIR"
    mkdir -p "$HISTORY_DIR"
}

# Run cargo audit with JSON output
run_cargo_audit() {
    local output_file="$REPORTS_DIR/audit_results.json"
    local audit_args="--json"

    if [[ -n "$AUDIT_DB_PATH" ]]; then
        audit_args="$audit_args --db $AUDIT_DB_PATH"
    fi

    if [[ -n "$EMERGENCY_CVE" ]]; then
        audit_args="$audit_args --cve $EMERGENCY_CVE"
    fi

    log_info "Running cargo audit..."
    cd "$PROJECT_ROOT"

    if cargo audit $audit_args > "$output_file" 2>&1; then
        log_success "Cargo audit completed successfully"
    else
        local exit_code=$?
        if [[ $exit_code -eq 1 ]]; then
            log_warn "Cargo audit found vulnerabilities"
        else
            log_error "Cargo audit failed with exit code $exit_code"
            return $exit_code
        fi
    fi

    echo "$output_file"
}

# Run cargo deny check
run_cargo_deny() {
    local output_file="$REPORTS_DIR/deny_results.json"

    log_info "Running cargo deny check..."
    cd "$PROJECT_ROOT"

    if cargo deny check --format json > "$output_file" 2>&1; then
        log_success "Cargo deny check completed successfully"
    else
        local exit_code=$?
        log_error "Cargo deny check failed with exit code $exit_code"
        return $exit_code
    fi

    echo "$output_file"
}

# Parse audit results and extract vulnerabilities
parse_audit_results() {
    local audit_file="$1"
    local vulnerabilities=()

    if [[ ! -f "$audit_file" ]]; then
        log_error "Audit results file not found: $audit_file"
        return 1
    fi

    # Extract vulnerabilities from JSON
    while IFS= read -r vuln; do
        vulnerabilities+=("$vuln")
    done < <(jq -r '.vulnerabilities.list[]? | @base64' "$audit_file" 2>/dev/null || true)

    echo "${vulnerabilities[@]}"
}

# Parse deny results
parse_deny_results() {
    local deny_file="$1"
    local violations=()

    if [[ ! -f "$deny_file" ]]; then
        log_error "Deny results file not found: $deny_file"
        return 1
    fi

    # Extract violations from JSON
    while IFS= read -r violation; do
        violations+=("$violation")
    done < <(jq -r '.[]? | @base64' "$deny_file" 2>/dev/null || true)

    echo "${violations[@]}"
}

# Check for critical vulnerabilities
check_critical_vulnerabilities() {
    local audit_file="$1"
    local critical_count=0

    if [[ ! -f "$audit_file" ]]; then
        return 0
    fi

    # Count critical vulnerabilities
    critical_count=$(jq -r '[.vulnerabilities.list[]? | select(.advisory.severity == "critical")] | length' "$audit_file" 2>/dev/null || echo "0")

    if [[ "$critical_count" -gt 0 ]]; then
        log_error "Found $critical_count critical vulnerabilities!"
        if [[ "$FAIL_ON_CRITICAL" == "true" ]]; then
            log_error "Failing build due to critical vulnerabilities (FAIL_ON_CRITICAL=true)"
            return 1
        fi
    fi

    return 0
}

# Generate security reports
generate_reports() {
    local audit_file="$1"
    local deny_file="$2"
    local timestamp
    timestamp=$(date -u +"%Y%m%d_%H%M%S")

    local report_file="$REPORTS_DIR/security_report_$timestamp.json"
    local html_file="$REPORTS_DIR/security_report_$timestamp.html"

    log_info "Generating security reports..."

    # Create JSON report
    {
        echo "{"
        echo "\"timestamp\": \"$timestamp\","
        echo "\"audit_results\": $(cat "$audit_file" 2>/dev/null || echo "{}"),"
        echo "\"deny_results\": $(cat "$deny_file" 2>/dev/null || echo "[]"),"
        echo "\"severity_threshold\": \"$SEVERITY_THRESHOLD\","
        echo "\"emergency_cve\": \"$EMERGENCY_CVE\""
        echo "}"
    } > "$report_file"

    # Generate HTML report if requested
    if [[ "$GENERATE_HTML" == "true" ]]; then
        generate_html_report "$report_file" "$html_file"
    fi

    log_success "Reports generated: $report_file"
    if [[ "$GENERATE_HTML" == "true" ]]; then
        log_success "HTML report: $html_file"
    fi
}

# Generate HTML report
generate_html_report() {
    local json_file="$1"
    local html_file="$2"

    cat > "$html_file" << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>Rust AI IDE Security Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background: #2c3e50; color: white; padding: 20px; border-radius: 5px; }
        .vulnerability { background: #f8f9fa; border-left: 4px solid #dc3545; padding: 15px; margin: 10px 0; }
        .violation { background: #f8f9fa; border-left: 4px solid #ffc107; padding: 15px; margin: 10px 0; }
        .summary { background: #e9ecef; padding: 15px; border-radius: 5px; margin: 20px 0; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Rust AI IDE Security Report</h1>
        <p>Generated on: <span id="timestamp"></span></p>
    </div>

    <div class="summary">
        <h2>Summary</h2>
        <p id="summary-content"></p>
    </div>

    <h2>Vulnerabilities</h2>
    <div id="vulnerabilities"></div>

    <h2>Policy Violations</h2>
    <div id="violations"></div>
</body>
</html>
EOF

    # This is a basic HTML template; in a real implementation,
    # we'd use jq to populate the content dynamically
}

# Generate dependency update recommendations
generate_recommendations() {
    local audit_file="$1"
    local recommendations_file="$REPORTS_DIR/update_recommendations.txt"

    log_info "Generating update recommendations..."

    {
        echo "=== Dependency Update Recommendations ==="
        echo "Generated on: $(date)"
        echo ""

        # Extract vulnerable packages and suggest updates
        if [[ -f "$audit_file" ]]; then
            echo "Vulnerable Dependencies:"
            jq -r '.vulnerabilities.list[]? | "- \(.package.name) \(.package.version): \(.advisory.title)"' "$audit_file" 2>/dev/null || echo "None found"
            echo ""

            echo "Suggested Actions:"
            jq -r '.vulnerabilities.list[]? | "1. Update \(.package.name) to a patched version"' "$audit_file" 2>/dev/null || echo "No specific actions available"
        fi
    } > "$recommendations_file"

    log_success "Recommendations saved to: $recommendations_file"
}

# Create alerts for new vulnerabilities
create_alerts() {
    local audit_file="$1"
    local history_file="$HISTORY_DIR/last_scan.json"

    # Load previous scan results
    local previous_vulns=""
    if [[ -f "$history_file" ]]; then
        previous_vulns=$(jq -r '.vulnerabilities.list[]? | "\(.package.name)-\(.advisory.id)"' "$history_file" 2>/dev/null || echo "")
    fi

    # Get current vulnerabilities
    local current_vulns=""
    if [[ -f "$audit_file" ]]; then
        current_vulns=$(jq -r '.vulnerabilities.list[]? | "\(.package.name)-\(.advisory.id)"' "$audit_file" 2>/dev/null || echo "")
    fi

    # Find new vulnerabilities
    local new_vulns=()
    for vuln in $current_vulns; do
        if ! echo "$previous_vulns" | grep -q "^$vuln$"; then
            new_vulns+=("$vuln")
        fi
    done

    if [[ ${#new_vulns[@]} -gt 0 ]]; then
        log_warn "Found ${#new_vulns[@]} new vulnerabilities!"

        # Send Slack alert if webhook configured
        if [[ -n "$SLACK_WEBHOOK" ]]; then
            send_slack_alert "${new_vulns[@]}"
        fi

        # Send email alert if recipients configured
        if [[ -n "$EMAIL_RECIPIENTS" ]]; then
            send_email_alert "${new_vulns[@]}"
        fi
    fi
}

# Send Slack alert
send_slack_alert() {
    local new_vulns=("$@")
    local message="ðŸš¨ *New Security Vulnerabilities Detected* ðŸš¨\\n\\nFound ${#new_vulns[@]} new vulnerabilities in Rust AI IDE.\\n\\nVulnerabilities:\\n$(printf -- "- %s\\n" "${new_vulns[@]}")\\n\\nPlease review the security report for details."

    curl -X POST -H 'Content-type: application/json' \
        --data "{\"text\":\"$message\"}" \
        "$SLACK_WEBHOOK" 2>/dev/null || log_warn "Failed to send Slack alert"
}

# Send email alert
send_email_alert() {
    local new_vulns=("$@")
    local subject="Rust AI IDE: New Security Vulnerabilities Detected"
    local body="Found ${#new_vulns[@]} new vulnerabilities:\n\n$(printf -- "- %s\n" "${new_vulns[@]}")\n\nPlease review the security report for details."

    # Note: Requires mail command to be configured
    echo -e "$body" | mail -s "$subject" "$EMAIL_RECIPIENTS" 2>/dev/null || log_warn "Failed to send email alert"
}

# Historical vulnerability tracking
historical_tracking() {
    local audit_file="$1"
    local timestamp
    timestamp=$(date -u +"%Y%m%d_%H%M%S")
    local history_file="$HISTORY_DIR/scan_$timestamp.json"

    # Copy current results to history
    cp "$audit_file" "$history_file" 2>/dev/null || true

    # Update last scan reference
    cp "$audit_file" "$HISTORY_DIR/last_scan.json" 2>/dev/null || true

    # Clean up old history files (keep last 30 days)
    find "$HISTORY_DIR" -name "scan_*.json" -mtime +30 -delete 2>/dev/null || true

    log_info "Historical data updated"
}

# Filter vulnerabilities by severity
filter_by_severity() {
    local audit_file="$1"
    local filtered_file="$REPORTS_DIR/filtered_vulnerabilities.json"

    if [[ ! -f "$audit_file" ]]; then
        return
    fi

    local severity_filter=""
    case "$SEVERITY_THRESHOLD" in
        "low")
            severity_filter="low|medium|high|critical"
            ;;
        "medium")
            severity_filter="medium|high|critical"
            ;;
        "high")
            severity_filter="high|critical"
            ;;
        "critical")
            severity_filter="critical"
            ;;
        *)
            log_warn "Invalid severity threshold: $SEVERITY_THRESHOLD. Using 'medium'"
            severity_filter="medium|high|critical"
            ;;
    esac

    jq --arg filter "$severity_filter" '{
        vulnerabilities: {
            list: [.vulnerabilities.list[]? | select(.advisory.severity | test($filter))],
            count: [.vulnerabilities.list[]? | select(.advisory.severity | test($filter))] | length
        }
    }' "$audit_file" > "$filtered_file"

    log_info "Filtered vulnerabilities saved to: $filtered_file"
}

# Main function
main() {
    log_info "Starting Rust AI IDE Vulnerability Scanner"

    # Setup
    check_dependencies
    setup_directories

    # Run security scans
    local audit_results deny_results

    if audit_results=$(run_cargo_audit); then
        log_success "Audit scan completed"
    else
        log_error "Audit scan failed"
        exit 1
    fi

    if deny_results=$(run_cargo_deny); then
        log_success "Deny check completed"
    else
        log_error "Deny check failed"
        exit 1
    fi

    # Process results
    parse_audit_results "$audit_results"
    parse_deny_results "$deny_results"

    # Check for critical vulnerabilities
    if ! check_critical_vulnerabilities "$audit_results"; then
        exit 1
    fi

    # Filter by severity
    filter_by_severity "$audit_results"

    # Generate reports and recommendations
    generate_reports "$audit_results" "$deny_results"
    generate_recommendations "$audit_results"

    # Handle alerts and history
    create_alerts "$audit_results"
    historical_tracking "$audit_results"

    log_success "Vulnerability scan completed successfully"
}

# Handle command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --emergency-cve)
            EMERGENCY_CVE="$2"
            shift 2
            ;;
        --severity-threshold)
            SEVERITY_THRESHOLD="$2"
            shift 2
            ;;
        --fail-on-critical)
            FAIL_ON_CRITICAL="$2"
            shift 2
            ;;
        --generate-html)
            GENERATE_HTML="$2"
            shift 2
            ;;
        --help|-h)
            echo "Usage: $0 [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --emergency-cve CVE       Scan for specific CVE"
            echo "  --severity-threshold LEVEL Filter by severity (low|medium|high|critical)"
            echo "  --fail-on-critical BOOL   Fail build on critical vulnerabilities"
            echo "  --generate-html BOOL      Generate HTML reports"
            echo "  --help                    Show this help"
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Run main function
main "$@"