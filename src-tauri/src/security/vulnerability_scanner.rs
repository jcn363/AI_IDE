use cargo_metadata::Package;
use rustsec::{Database, Error as RustSecError, RegistryClient};
use serde::Serialize;
use std::path::Path;

pub struct VulnerabilityScanner {
    db: Database,
}

impl VulnerabilityScanner {
    pub fn new() -> Result<Self, RustSecError> {
        // Load the advisory database
        let db = Database::fetch()?;
        Ok(Self { db })
    }

    pub fn check_dependencies(&self, manifest_path: &Path) -> Vec<VulnerabilityReport> {
        let mut reports = Vec::new();

        // Load Cargo.lock
        if let Ok(lockfile) = cargo_lock::Lockfile::load(manifest_path) {
            for vuln in self.db.vulnerabilities(&lockfile) {
                let advisory = &vuln.advisory;
                let package = &vuln.package;

                reports.push(VulnerabilityReport {
                    package: package.name.to_string(),
                    version: package.version.to_string(),
                    advisory: advisory.clone(),
                    severity: Some(
                        advisory
                            .cvss
                            .as_ref()
                            .map(|c| c.severity())
                            .unwrap_or(rustsec::Severity::Medium),
                    ),
                });
            }
        }

        reports
    }
}

#[derive(Debug, Serialize)]
pub struct VulnerabilityReport {
    pub package: String,
    pub version: String,
    pub advisory: rustsec::advisory::Metadata,
    pub severity: Option<rustsec::Severity>,
}
