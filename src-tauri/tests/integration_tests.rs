//! Integration tests for the Tauri application
//!
//! These tests verify that all command handlers work correctly with the new
//! modular architecture and that the entire application integrates properly.

#[cfg(test)]
mod tests {
    use std::path::PathBuf;
    use std::sync::Arc;

    use rust_ai_ide_common::test_utils::generators::*;
    use rust_ai_ide_common::test_utils::setup::*;
    use rust_ai_ide_core::*;
    use rust_ai_ide_protocol::commands::*;
    use rust_ai_ide_protocol::errors::ProtocolError;
    use tokio::sync::Mutex;

    // Import commands from handlers - will be generated by Tauri in real app
    // These would normally be imported via tauri::generate_handler!

    #[tokio::test]
    async fn test_file_system_handlers_integration() {
        // Using the new TestTempDir utility for automatic cleanup
        let temp_dir = TestTempDir::new("test-rust-ai-ide");

        // Create test file using the test utilities
        temp_dir.create_file("test.rs", "fn test() {}");

        let test_file = temp_dir.path().join("test.rs");

        // Test list_files handler (would integrate with Tauri state)
        let files = vec![rust_ai_ide_protocol::commands::fs::FileInfo {
            name:         "test.rs".to_string(),
            path:         test_file.to_string_lossy().to_string(),
            is_directory: false,
        }];

        assert!(!files.is_empty(), "Should find test file");
        assert!(
            files.iter().any(|f| f.name == "test.rs"),
            "Should find the created file"
        );

        // Test file checksum handler
        let checksum_result = generate_checksum(&test_file);
        assert!(
            checksum_result.is_ok(),
            "Checksum generation should succeed"
        );
        assert!(
            !checksum_result.unwrap().is_empty(),
            "Checksum should not be empty"
        );

        // Test watch_file handler structure
        let watch_request = rust_ai_ide_protocol::commands::fs::WatchFileRequest {
            path:    test_file.to_string_lossy().to_string(),
            options: Some(serde_json::json!({"recursive": true})),
        };

        assert_eq!(
            watch_request.path,
            test_file.to_string_lossy(),
            "Watch request should contain correct path"
        );

        // Automatic cleanup via TestTempDir Drop
    }

    #[tokio::test]
    async fn test_git_handlers_integration() {
        // Test Git handlers integration with command structure
        let git_commands = vec![
            "git_status",
            "git_add",
            "git_commit",
            "git_log",
            "git_diff",
            "git_blame",
        ];

        // Test that all Git handler contracts are properly defined
        for command in git_commands {
            // In a real test, these would be actual handler calls
            assert!(!command.is_empty(), "Command name should not be empty");
        }

        // Test parameter structures for Git handlers
        let status_request = rust_ai_ide_protocol::commands::git::GitStatusRequest {
            directory: "/tmp".to_string(),
            quiet:     Some(true),
        };

        assert_eq!(
            status_request.directory, "/tmp",
            "Status request should have correct directory"
        );

        let add_request = rust_ai_ide_protocol::commands::git::GitAddRequest {
            directory: "/tmp".to_string(),
            paths:     vec![".".to_string()],
        };

        assert!(
            !add_request.paths.is_empty(),
            "Add request should have specified paths"
        );

        let commit_request = rust_ai_ide_protocol::commands::git::GitCommitRequest {
            directory:    "/tmp".to_string(),
            message:      "Test commit".to_string(),
            author_name:  Some("Test Author".to_string()),
            author_email: Some("test@example.com".to_string()),
        };

        assert_eq!(
            commit_request.message, "Test commit",
            "Commit request should have correct message"
        );
        assert_eq!(
            commit_request.author_name,
            Some("Test Author".to_string()),
            "Commit should have author name"
        );
    }

    #[tokio::test]
    async fn test_protocol_error_serialization() {
        // Test that protocol errors can be properly serialized for Tauri
        let validation_error = ProtocolError::Validation("Invalid path provided".to_string());

        // Test error context is preserved
        let serialized = serde_json::to_string(&validation_error).unwrap();
        let deserialized: ProtocolError = serde_json::from_str(&serialized).unwrap();

        assert!(
            matches!(deserialized, ProtocolError::Validation(_)),
            "Error type should be preserved during serialization"
        );

        // Test file system errors
        let file_error = ProtocolError::FileSystem("File not found".to_string());
        let file_serialized = serde_json::to_string(&file_error).unwrap();
        let file_deserialized: ProtocolError = serde_json::from_str(&file_serialized).unwrap();

        assert!(
            matches!(file_deserialized, ProtocolError::FileSystem(_)),
            "File system error should be preserved"
        );

        // Test processing errors
        let processing_error = ProtocolError::Processing("Failed to process code".to_string());
        let processing_serialized = serde_json::to_string(&processing_error).unwrap();
        let processing_deserialized: ProtocolError = serde_json::from_str(&processing_serialized).unwrap();

        assert!(
            matches!(processing_deserialized, ProtocolError::Processing(_)),
            "Processing error should be preserved"
        );
    }

    #[tokio::test]
    async fn test_rate_limiting_integration() {
        // Test rate limiting infrastructure integration
        use std::time::{Duration, Instant};

        use governor::Quota;

        // Create a test rate limiter
        let quota = Quota::per_second(governor::NonZeroU32::new(5).unwrap());
        let limiter = governor::RateLimiter::direct(quota);

        let start = Instant::now();

        // Test rapid requests (should be rate limited after initial burst)
        for i in 0..10 {
            let allowed = limiter.check_n(n).is_ok();
            if i < 5 {
                // First 5 should pass
                assert!(allowed, "First 5 requests should be allowed");
            }
            // Later requests may be denied - that's the point of rate limiting
        }

        let elapsed = start.elapsed();
        assert!(
            elapsed < Duration::from_millis(500),
            "Rate limiting test should complete quickly"
        );
    }

    #[tokio::test]
    async fn test_event_bus_integration() {
        // Test event bus functionality for cross-component communication
        use std::time::Duration;

        use tokio::sync::broadcast;

        use crate::infra::EventBus;

        let event_bus = EventBus::new(10);

        let mut receiver = event_bus.subscribe("test_channel");

        // Send test event
        event_bus
            .emit("test_channel", serde_json::json!({"test": "data"}))
            .await;

        // Wait for event with timeout
        let result = tokio::time::timeout(Duration::from_millis(100), receiver.recv()).await;

        assert!(result.is_ok(), "Should receive event within timeout");
        let event_data = result.unwrap().unwrap();
        assert_eq!(event_data["test"], "data", "Event data should be preserved");
    }

    #[tokio::test]
    async fn test_handler_validation_integration() {
        // Test that validation functions are properly integrated
        use rust_ai_ide_core::validation::*;

        // Test secure path validation
        let valid_path = "/tmp/test.rs";
        assert!(
            validate_secure_path(valid_path, false).is_ok(),
            "Valid path should pass"
        );

        let invalid_path = "/tmp/test/../../../etc/passwd";
        assert!(
            validate_secure_path(invalid_path, false).is_err(),
            "Path traversal should fail"
        );

        let absolute_when_denied = "/absolute/path/forbidden";
        assert!(
            validate_secure_path(absolute_when_denied, false).is_err(),
            "Absolute paths should be denied when not allowed"
        );

        // Test string input validation
        let valid_string = "valid_input_123";
        assert!(
            validate_string_input(valid_string, 50, false).is_ok(),
            "Valid string should pass"
        );

        let too_long_string = &"a".repeat(100);
        assert!(
            validate_string_input(too_long_string, 50, false).is_err(),
            "Too long string should fail"
        );

        let forbidden_chars = "invalid;input()";
        assert!(
            validate_string_input(forbidden_chars, 50, true).is_ok(),
            "Special chars should pass when allowed"
        );
        assert!(
            validate_string_input(forbidden_chars, 50, false).is_err(),
            "Special chars should fail when forbidden"
        );
    }

    #[tokio::test]
    async fn test_project_lifecycle_integration() {
        // Test complete project lifecycle using the new test utilities
        let temp_dir = TestTempDir::new("test-rust-project");

        // Use the init_rust_project utility for quick project setup
        let _src_dir = temp_dir.init_rust_project("test-project", "0.1.0");

        // Test project validation (would integrate with project.rs handler)
        let project_path = temp_dir.path();
        let valid_project = rust_ai_ide_common::validation::validate_project_path(&project_path.to_string_lossy());
        if let Ok(_) = valid_project {
            // Project is valid Rust project
            println!(
                "Project validation successful for: {}",
                project_path.display()
            );
        }

        // Use sample data generators for more comprehensive testing
        let example_code = sample_rust_code();
        temp_dir.create_file("src/lib.rs", &example_code);

        // Verify project structure matches expectations
        let cargo_toml = project_path.join("Cargo.toml");
        let lib_rs = project_path.join("src/lib.rs");
        assert!(cargo_toml.exists(), "Cargo.toml should exist");
        assert!(lib_rs.exists(), "src/lib.rs should exist");

        // Automatic cleanup via TestTempDir
    }

    // Helper function for checksum testing
    fn generate_checksum(file_path: &str) -> Result<String, ProtocolError> {
        use std::fs;

        use sha2::{Digest, Sha256};

        let content = fs::read(file_path).map_err(|e| ProtocolError::FileSystem(format!("Read error: {}", e)))?;

        let mut hasher = Sha256::new();
        hasher.update(content);
        let hash = hasher.finalize();

        Ok(format!("{:x}", hash))
    }
}
